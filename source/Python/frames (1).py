# -*- coding: utf-8 -*-
"""Frames.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1_t7Y9mA1yYyQEywnzHx6HuUwSJsM4qW0
"""

def Frames(data,Frame_Size=0.025,Overlap=0.4,samplerate=12500):
  Frame_Length = {}
  Frame_Step = {}
  num_frames = {}
  WF = {}  # Windowed Frames


  # It is better to chunk the original signal into frames of smaller length
  # Frame length can be found by multiplying the samplerate by framesize. 
  # Frame size is typically between 0.025 seconds and 0.01 seconds
  # The frame length is rounded to nearest integer
  #Frame_Size = 0.025
  for signal in range(len(data)):
    Frame_Length[signal] = samplerate*Frame_Size
    Frame_Length[signal] = int(round(Frame_Length[signal])) 
    # It is important to have overlap between frames
    # Frame_Step can be found by multiplying the samplerate by framestride
    # Frame Stride is found based on the amount of desired overlap (40-60%)
    # The overlap is rounded to nearest integer
    Frame_Stride = Overlap*Frame_Size
    Frame_Step[signal] = Frame_Stride*samplerate
    Frame_Step[signal] = int(round(Frame_Step[signal]))


    # Determine the number of frames 
    # The number of samples in the original signal divided by the overlaps
    num_frames[signal] = int(np.ceil(float(np.absolute(len(data[signal])-Frame_Length[signal]))/Frame_Step[signal])) 

    # Padding required to separate original signal into equal lengthed chunks 
    pad_signal_length = num_frames[signal] * Frame_Step[signal] + Frame_Length[signal]
    reqd_zeros = np.zeros((pad_signal_length - len(data[signal])))
    data[signal] = np.append(data[signal],reqd_zeros)


    # Next you want to find the indicies for the frames you have set up
    # There should be 'num_frames' frames with length 'Frame_Length'
    # https://numpy.org/doc/stable/reference/generated/numpy.tile.html useful
    ind1 = np.tile(np.arange(0, Frame_Length[signal]), (num_frames[signal], 1)) 
    ind2 = np.tile(np.arange(0, num_frames[signal] * Frame_Step[signal], Frame_Step[signal]), (Frame_Length[signal], 1)).T
    ind3 = ind1 + ind2
    ind1df = pd.DataFrame(ind1,)
    ind2df = pd.DataFrame(ind2)
    ind3df = pd.DataFrame(ind3)

    # Assign frame values at specified indices
    frames = data[signal][ind3.astype(np.int32, copy=False)]

    # Window the framed data (hamming window's generally work well)
    window = sps.hamming(Frame_Length[signal])
    WF[signal] = window[signal]*frames


  return(WF)