# -*- coding: utf-8 -*-
"""cluster_buster.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1SEV6KOFbSgRnzT7hWxtqsypY2YGAkG5V
"""

def cluster_buster(data, M, ep = 0.01):
  centroids = {}
  MFCCs = data
  print(np.shape(MFCCs))
  centroids = np.array([np.mean(MFCCs,axis=0)])
  print(np.shape(centroids))

  D = 1000
  D_prime = 1500
  m=1
  #This is where the splitting occurs
  while int(m) < int(M): # If condition to split is met then split
    centroid_plus = centroids*(ep+1)
    centroid_minus = centroids*(1-ep)
    #print('centroid minus is: ',centroid_minus)
    #print('centroid plus is: ',centroid_plus)
    centroids = np.concatenate((centroid_plus,centroid_minus),axis=0)
    m *= 2 # for the peeps
    check = ep+1
    while check > ep:
      D_prime = D
      index = np.zeros(np.shape(MFCCs)[0])
      count = np.zeros([m,1])
      min_dist = np.ones(np.shape(MFCCs)[0])*1E4
      new_centroids = np.zeros([m,12])
      for data_point in range(np.shape(MFCCs)[0]):
        for centroid in range(m):
          temp_dist = np.linalg.norm(MFCCs[data_point] - centroids[centroid])
          if temp_dist < min_dist[data_point]:
            min_dist[data_point] = temp_dist # distance current point is from centroid
            index[data_point] = centroid # the closest centroid for the given point
        new_centroids[int(index[data_point])] += MFCCs[data_point]
        count[int(index[data_point])] += 1

      for centroid in range(m):
        #print('new centroids is:',new_centroids[centroid,:])
        #print('count is ', count[centroid])
        new_centroids[centroid,:] = new_centroids[centroid,:]/count[centroid]
      centroids = new_centroids
      #print('new centroids are\n', pd.DataFrame(new_centroids))
    
      D = 0
      for data_point in range(np.shape(MFCCs)[0]):
        min_dist = 1E4
        for centroid in range(m):
          temp_dist = np.linalg.norm(MFCCs[data_point] - centroids[centroid])
          if temp_dist < min_dist:
            min_dist = temp_dist # distance current point is from centroid
        D += min_dist
      check = np.abs((D_prime-D)/D)


  cluster = {}
  for centroid in range(m):
    cluster[centroid] = np.where(index == centroid)

  return(cluster, centroids)