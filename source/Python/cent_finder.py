# -*- coding: utf-8 -*-
"""Cent_Finder.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11QsU9QJ5N80QgdJBfDwMvEfxfVWbSk-z
"""

def Cent_Finder(data,M=8,ep=0.01):
  # Find's M number of centroids for a given data set
  cycles = int(np.log2(M))
  C = {}
  temp = {}
  D_cent = {}
  C[str(0)] = np.zeros(np.shape(data)[1])
  D_prime = 15000
  D = 14900
  m=1
  k=1
  ep = 0.01
  L = {}
  for dimension in range(np.shape(data)[1]):
    C[str(0)][dimension] = np.mean(data[:,dimension])
  temp[str(0)] = C[str(0)]

  for cycle in range(cycles):
      


      #This is where the splitting occurs

      check = float(np.abs((D_prime-D)/D))
      while check < ep and int(m) < int(M): # If condition to split is met then split
        for key in range(len(C)):
          C[str(key*2)] = temp[str(key)]*(1+ep) 
          C[str(key*2+1)] = temp[str(key)]*(1-ep)
        for key in range(len(C)): 
          temp[str(key)] = C[str(key)]
        DF_C = pd.DataFrame(C)
      

        
        for centroid in range(np.shape(DF_C)[1]):
          L[str(centroid)] = []


        for frame in range(np.shape(data)[0]):
          index = 0
          test = 1E4
          
          
          for value in range(np.shape(DF_C)[1]):
            if np.abs(np.linalg.norm(data[frame,:]-C[str(value)])) < test: 
              #print('frame ',frame,'goes in dimension',value)
              test = np.abs(np.linalg.norm(data[frame,:]-C[str(value)]))
              index = value 
          L[str(index)].append(data[frame])
        

        for centroid in range(np.shape(DF_C)[1]):
          #print('centroid is: ',centroid)
          D1 = np.array(L[str(centroid)])
          DF1 = pd.DataFrame(L[str(centroid)])
          DF2 = DF1.mean(axis=0)
          D2 = np.array(DF2)
          
          for row in range(np.shape(D1)[0]):
            dist_from_cent = np.linalg.norm(D1[row]-D2)
            D = D+float(dist_from_cent)

          C[str(centroid)] = DF2
        for key in range(len(C)): 
          temp[str(key)] = C[str(key)]
        DF_C = pd.DataFrame(C)
        # Next you must find the distortion 'D'
        D=0
        for centroid in L:
          for row in range(np.shape(L[centroid])[0]):

            D = np.linalg.norm(L[centroid][row]-DF2)+D

        check = float(np.abs((D_prime-D)/D))
        for key in range(len(C)): 
          temp[str(key)] = C[str(key)]
        DF_C = pd.DataFrame(C)
        m=len(C)


      # This is where centroid is adjusted if condition isnt met

      check = float(np.abs((D_prime-D)/D))
      while check > ep and int(m) <= int(M): 
        #print(m)
        D_prime = D


        for centroid in range(len(C)):

          if centroid % 2 == 0:
            C[str(centroid)] = C[str(centroid)]*(1+ep)
          else:
            C[str(centroid)] = C[str(centroid)]*(1-ep) 

        for key in range(len(C)): 
          temp[str(key)] = C[str(key)]
        DF_C = pd.DataFrame(C)
      

        L = {}
        for centroid in range(np.shape(DF_C)[1]):
          L[str(centroid)] = []
          #print('first key for L is: ',centroid)
        #print(pd.DataFrame(C))
        for frame in range(np.shape(data)[0]):
          index = 0
          test = 1E4
          #print(pd.DataFrame(C))
          for centroid in range(np.shape(DF_C)[1]):
            #print('shape of frame: ',np.shape(data[frame,:]))
            #print('shape of C: ',np.shape(C[str(centroid)]))
            if np.abs(np.linalg.norm(data[frame,:]-C[str(centroid)])) < test: 
              test = np.abs(np.linalg.norm(data[frame,:]-C[str(centroid)]))
              index = centroid 
          L[str(index)].append(data[frame])

        


        for centroid in range(np.shape(DF_C)[1]):
          #print('centroid is: ',centroid)
          D1 = np.array(L[str(centroid)])
          DF1 = pd.DataFrame(L[str(centroid)])
          DF2 = DF1.mean(axis=0)
          D2 = np.array(DF2)
          
          for row in range(np.shape(D1)[0]):
            dist_from_cent = np.linalg.norm(D1[row]-D2)
            D = D+float(dist_from_cent)

        
          C[str(centroid)] = DF2

        for key in range(len(C)): 
          temp[str(key)] = C[str(key)]
        DF_C = pd.DataFrame(C)
        # Next you must find the distortion 'D'
        D=0
        for centroid in L:
          for row in range(np.shape(L[centroid])[0]):

            D = np.linalg.norm(L[centroid][row]-DF2)+D

        check = float(np.abs((D_prime-D)/D))
        m=len(C)

  clusters = L
  DF_C2 = np.array(DF_C)
  return(DF_C2,clusters)

code = {}
cluster = {}
for set in range(num_train):
  code[set], cluster[set] = Cent_Finder(mfcc[set])