# -*- coding: utf-8 -*-
"""MELFB_own.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1x-mfmNTX02e5jOlvt6FGCGgtGxYB4-gI
"""

def MELFB_own(data,Frame_Size=0.025,Overlap=0.4,samplerate=12500):
  # It is better to chunk the original signal into frames of smaller length
  # Frame length can be found by multiplying the samplerate by framesize. 
  # Frame size is typically between 0.025 seconds and 0.01 seconds
  # The frame length is rounded to nearest integer
  #Frame_Size = 0.025
  Frame_Length = samplerate*Frame_Size
  Frame_Length = int(round(Frame_Length)) 
  #print(Frame_Length)
  #print('sample rate is: ', samplerate)

  # It is important to have overlap between frames
  # Frame_Step can be found by multiplying the samplerate by framestride
  # Frame Stride is found based on the amount of desired overlap (40-60%)
  # The overlap is rounded to nearest integer
  #Overlap = 0.4
  Frame_Stride = Overlap*Frame_Size
  Frame_Step = Frame_Stride*samplerate
  Frame_Step = int(round(Frame_Step))
  #print(Frame_Step)


  # Determine the number of frames 
  # The number of samples in the original signal divided by the overlaps
  num_frames = int(np.ceil(float(np.absolute(len(data)-Frame_Length))/Frame_Step)) 
  #print('number of frames: ',num_frames)

  # Padding required to separate original signal into equal lengthed chunks 
  pad_signal_length = num_frames * Frame_Step + Frame_Length
  #print('Original signal length was:\n',len(data),'\nNew signal length is:\n',pad_signal_length)
  reqd_zeros = np.zeros((pad_signal_length - len(data)))
  data = np.append(data,reqd_zeros)
  #print('Length of the padded signal is:\n',len(data))

  # Next you want to find the indicies for the frames you have set up
  # There should be 'num_frames' frames with length 'Frame_Length'
  # https://numpy.org/doc/stable/reference/generated/numpy.tile.html useful
  ind1 = np.tile(np.arange(0, Frame_Length), (num_frames, 1)) 
  ind2 = np.tile(np.arange(0, num_frames * Frame_Step, Frame_Step), (Frame_Length, 1)).T
  ind3 = ind1 + ind2
  ind1df = pd.DataFrame(ind1,)
  ind2df = pd.DataFrame(ind2)
  ind3df = pd.DataFrame(ind3)
  #print((ind1df.head(1)))
  #print((ind2df.head(1)))
  #print(ind3df.head(2))


  # Assign frame values at specified indices
  frames = data[ind3.astype(np.int32, copy=False)]


  # Window the framed data (hamming window's generally work well)
  window = sps.hamming(Frame_Length)
  windowed_frames = window*frames
  
  return(windowed_frames)
