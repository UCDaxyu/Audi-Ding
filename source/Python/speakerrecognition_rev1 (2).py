# -*- coding: utf-8 -*-
"""SpeakerRecognition_rev1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1qBeKrqYebtBMqKyBH-P6t9xjwLoUgOK8
"""

from google.colab import drive
drive.mount('/content/drive')

### Imports ###
import numpy as np
import scipy.signal as sps
from scipy.io import wavfile
import matplotlib.pyplot as plt
from matplotlib import patches
import pandas as pd
pd.set_option("display.precision",2)
pd.set_option('display.max_columns', None)
pd.set_option('display.max_rows', None)
from IPython.display import Audio
from scipy.fft import fft, dct
from matplotlib import cm
from scipy.cluster.vq import whiten

#### Defined Functions ####
num_filt = 20
f_samp = 12500
num_FFT = 512
myFrames = {}
num_filt = 20
num_FFT = 512
f_samp = 12500
freq = np.linspace(0,f_samp,int(num_FFT/2)+1)
M = 8
file_bin = '/content/drive/MyDrive/Colab Notebooks/EEC 201/Final Project/Training/s'

#### Tested Functions ####
def find_audio(file_bin,num_signals,pre_emphasis=0.97):
  t = {} # Dictionary of time for each signal
  SR = {} # Dictionary of test signal sample rates
  D_train = {} # Dictionary of test signal data sets
  for signal in range(num_signals):
    SR[signal], D_train[signal] = wavfile.read(file_bin+str(signal+1)+'.wav') ### LOOK HERE 2
    try:
      D_train[signal] = D_train[signal][:,0]
      print('stereo signal present in your data set')
    except:
      pass
    D_train[signal] = np.append(D_train[signal][0], D_train[signal][1:] - pre_emphasis * D_train[signal][:-1])
    t[signal]=1/SR[signal]*np.array(range(len(D_train[signal])))
  return[t,SR,D_train]
def Frames(data,Frame_Size=0.025,Overlap=0.4,samplerate=12500):
  Frame_Length = {}
  Frame_Step = {}
  num_frames = {}
  WF = {}  # Windowed Frames


  # It is better to chunk the original signal into frames of smaller length
  # Frame length can be found by multiplying the samplerate by framesize. 
  # Frame size is typically between 0.025 seconds and 0.01 seconds
  # The frame length is rounded to nearest integer
  #Frame_Size = 0.025
  for signal in range(len(data)):
    Frame_Length[signal] = samplerate*Frame_Size
    Frame_Length[signal] = int(round(Frame_Length[signal])) 
    # It is important to have overlap between frames
    # Frame_Step can be found by multiplying the samplerate by framestride
    # Frame Stride is found based on the amount of desired overlap (40-60%)
    # The overlap is rounded to nearest integer
    Frame_Stride = Overlap*Frame_Size
    Frame_Step[signal] = Frame_Stride*samplerate
    Frame_Step[signal] = int(round(Frame_Step[signal]))


    # Determine the number of frames 
    # The number of samples in the original signal divided by the overlaps
    num_frames[signal] = int(np.ceil(float(np.absolute(len(data[signal])-Frame_Length[signal]))/Frame_Step[signal])) 

    # Padding required to separate original signal into equal lengthed chunks 
    pad_signal_length = num_frames[signal] * Frame_Step[signal] + Frame_Length[signal]
    reqd_zeros = np.zeros((pad_signal_length - len(data[signal])))
    data[signal] = np.append(data[signal],reqd_zeros)


    # Next you want to find the indicies for the frames you have set up
    # There should be 'num_frames' frames with length 'Frame_Length'
    # https://numpy.org/doc/stable/reference/generated/numpy.tile.html useful
    ind1 = np.tile(np.arange(0, Frame_Length[signal]), (num_frames[signal], 1)) 
    ind2 = np.tile(np.arange(0, num_frames[signal] * Frame_Step[signal], Frame_Step[signal]), (Frame_Length[signal], 1)).T
    ind3 = ind1 + ind2
    ind1df = pd.DataFrame(ind1,)
    ind2df = pd.DataFrame(ind2)
    ind3df = pd.DataFrame(ind3)

    # Assign frame values at specified indices
    frames = data[signal][ind3.astype(np.int32, copy=False)]

    # Window the framed data (hamming window's generally work well)
    window = sps.hamming(Frame_Length[signal])
    WF[signal] = window[signal]*frames


  return(WF)
def MAGPOW(Windowed_Frames,num_FFT=512):
  # Find the magnitude of the one sided FFT
  # Real valued signal so symmetry can be used to find other side
  # Power is 1/number of samples *the square of the signal 
  MAG = {}
  POW = {}
  POWdB = {}
  for signal in range(len(Windowed_Frames)):
    MAG[signal] = np.abs(np.fft.rfft(Windowed_Frames[signal], num_FFT))  # Magnitude of the FFT
    POW[signal] = ((1.0 / num_FFT) * ((MAG[signal]) ** 2))  # Power Spectrum
    POWdB[signal] = 10*np.log10(POW[signal])
  return(MAG,POW,POWdB)
def plot_POWdB(POWdB,t,fs):
  X = np.linspace(0,np.shape(POWdB)[0],5)
  Xlab = np.linspace(0,max(t),5)
  Y = np.linspace(0,np.shape(POWdB)[1],5)
  Ylab = np.linspace(0,f_samp/2,5)
  fig1, axs1 = plt.subplots(nrows=1,ncols=1,figsize=[10,5])
  c = axs1.pcolor(np.transpose(POWdB))
  axs1.set_title('Periodogram\nUsing My Own Power Spectral Density', weight='bold',fontsize=20,color='black')
  axs1.set_xticks(X)
  axs1.set_xticklabels(Xlab)
  axs1.set_yticks(Y)
  axs1.set_yticklabels(Ylab)
  plt.xticks(fontsize=15)
  plt.yticks(fontsize=15)
  axs1.set_ylabel('Frequency\n(Hertz)',weight='bold',size=15)
  axs1.set_xlabel('Time\n(Seconds)',weight='bold',size=15)
  fig1.colorbar(c , ax = axs1)
def melBanks(POW, num_filt, f_samp, num_FFT=512, Low_Freq=0):
  High_Freq = f_samp/2
  melMin = 1127*np.log(1+Low_Freq/700)
  melMax = 1127*np.log(1+High_Freq/700)
  mel_points = np.linspace(melMin,melMax,num_filt+2) # K+2 because the start and end points are excluded. Spacing refers to the mel points (hz to mels)
  hz_points = 700*(np.exp(mel_points/1125)-1)  # Convert Mel to Hz
  bank_index = np.floor((num_FFT + 1)*hz_points/f_samp) 
  filt_bank = np.zeros((num_filt, int(np.floor(num_FFT/2+1)))) # Sets up a zero matrix (number of cols will be == number of banks == num_filt length of col will be numFFT/2+1
  filter_banks = {}
  for signal in POW:
    for filter in range(1, num_filt + 1):
      # Set up the key points for the triangle (start, center, end)
      filt_start = int(bank_index[filter - 1])  # Left side of triangle
      filt_center = int(bank_index[filter])  # Peak of triangle   
      filt_end = int(bank_index[filter + 1]) # Right Side of triangle
      # fill in the important points for the triangle
      for point in range(filt_start, filt_center):
          filt_bank[filter - 1, point] = 2*(point - bank_index[filter - 1]) / (bank_index[filter] - bank_index[filter - 1])
      for point in range(filt_center, filt_end):
          filt_bank[filter - 1, point] = 2*(bank_index[filter + 1] - point) / (bank_index[filter + 1] - bank_index[filter])

      filter_banks[signal] = np.dot(POW[signal], filt_bank.T)
      filter_banks[signal] = np.where(filter_banks[signal] == 0, np.finfo(float).eps, filter_banks[signal])  # Numerical Stability
      filter_banks[signal] = np.log(filter_banks[signal]) 
  return(filt_bank,filter_banks)
def plot_BandPassBank(band_pass,freq):
  fig, ax1 = plt.subplots(nrows=1,ncols=1,figsize=[10,5])
  for FB in range(len(band_pass)):
    ax1.plot(freq,band_pass[FB],label='Filter'+str(FB))
  ax1.set_title('Band Pass Filter Bank\nMel Scale', weight='bold',fontsize=20,color='black')
  ax1.set_xlabel('Frequency \n Hertz',fontsize=15)
  ax1.set_ylabel('Magnitude',fontsize=15)
  ax1.grid()
  ax1.legend(bbox_to_anchor=(1.05, 1), loc=2)
def plot_melbanks(myBank_choice,t_choice,f_samp=12500):
  fig1, axs1 = plt.subplots(nrows=1,ncols=1,figsize=[10,5])

  X = np.linspace(0,np.shape(myBank_choice)[0],5)
  Xlab = np.linspace(0,max(t_choice),5)
  #Y = np.linspace(0,np.shape(myBank_choice)[1],5)
  #Ylab = np.linspace(0,f_samp/2,5)
  c = axs1.pcolor(np.transpose(myBank_choice))

  axs1.set_title('Mel-Spaced Filter Bank Response', weight='bold',fontsize=20,color='black')
  axs1.set_xticks(X)
  axs1.set_xticklabels(Xlab)
  #axs1.set_yticks(Y)
  #axs1.set_yticklabels(Ylab)
  plt.xticks(fontsize=15)
  plt.yticks(fontsize=15)
  axs1.set_ylabel('Frequency\n(Hertz)',weight='bold',size=15)
  axs1.set_xlabel('Time\n(Seconds)',weight='bold',size=15)
  fig1.colorbar(c , ax = axs1)
  plt.tight_layout()
def find_mfccs(myBanks,num_ceps):
  mfccs = {}
  for signal in range(len(myBanks)):
    mfccs[signal] = dct(myBanks[signal], type=2, axis=1, norm='ortho')[:, 1 : (num_ceps + 1)] # Keep 2-13
    mfccs[signal] = whiten(mfccs[signal]) 
  return(mfccs)
def plot_mfccs(mfcc_choice,t_choice):
  fig1, axs1 = plt.subplots(nrows=1,ncols=1,figsize=[10,5])
  X = np.linspace(0,np.shape(mfcc_choice)[0],5)
  Xlab = np.linspace(0,max(t_choice),5)
  c = axs1.pcolor(np.transpose(mfcc_choice))
  axs1.set_title('Completing the â€œCepstrum"', weight='bold',fontsize=20,color='black')
  axs1.set_xticks(X)
  axs1.set_xticklabels(Xlab)
  plt.xticks(fontsize=15)
  plt.yticks(fontsize=15)
  axs1.set_ylabel('MFCC Coefficients',weight='bold',size=15)
  axs1.set_xlabel('Time\n(Seconds)',weight='bold',size=15)
  fig1.colorbar(c , ax = axs1)
  plt.tight_layout()
def cluster_buster(data, M, ep = 0.01):
  centroids = {}
  MFCCs = data
  print(np.shape(MFCCs))
  centroids = np.array([np.mean(MFCCs,axis=0)])
  print(np.shape(centroids))

  D = 1000
  D_prime = 1500
  m=1
  #This is where the splitting occurs
  while int(m) < int(M): # If condition to split is met then split
    centroid_plus = centroids*(ep+1)
    centroid_minus = centroids*(1-ep)
    #print('centroid minus is: ',centroid_minus)
    #print('centroid plus is: ',centroid_plus)
    centroids = np.concatenate((centroid_plus,centroid_minus),axis=0)
    m *= 2 # for the peeps
    check = ep+1
    while check > ep:
      D_prime = D
      index = np.zeros(np.shape(MFCCs)[0])
      count = np.zeros([m,1])
      min_dist = np.ones(np.shape(MFCCs)[0])*1E4
      new_centroids = np.zeros([m,12])
      for data_point in range(np.shape(MFCCs)[0]):
        for centroid in range(m):
          temp_dist = np.linalg.norm(MFCCs[data_point] - centroids[centroid])
          if temp_dist < min_dist[data_point]:
            min_dist[data_point] = temp_dist # distance current point is from centroid
            index[data_point] = centroid # the closest centroid for the given point
        new_centroids[int(index[data_point])] += MFCCs[data_point]
        count[int(index[data_point])] += 1

      for centroid in range(m):
        #print('new centroids is:',new_centroids[centroid,:])
        #print('count is ', count[centroid])
        new_centroids[centroid,:] = new_centroids[centroid,:]/count[centroid]
      centroids = new_centroids
      #print('new centroids are\n', pd.DataFrame(new_centroids))
    
      D = 0
      for data_point in range(np.shape(MFCCs)[0]):
        min_dist = 1E4
        for centroid in range(m):
          temp_dist = np.linalg.norm(MFCCs[data_point] - centroids[centroid])
          if temp_dist < min_dist:
            min_dist = temp_dist # distance current point is from centroid
        D += min_dist
      check = np.abs((D_prime-D)/D)


  cluster = {}
  for centroid in range(m):
    cluster[centroid] = np.where(index == centroid)

  return(cluster, centroids)



#### Untested Functions ####


def SNR(SNR,data):
  # Set a target SNR
  target_snr_db = SNR
  # Calculate signal power and convert to dB 
  sig_avg_watts = np.mean(data**2)
  sig_avg_db = 10 * np.log10(sig_avg_watts)
  # Calculate noise according to [2] then convert to watts
  noise_avg_db = sig_avg_db - target_snr_db
  noise_avg_watts = 10 ** (noise_avg_db / 10)
  # Generate an sample of white noise
  mean_noise = 0
  added_noise = np.random.normal(mean_noise, np.sqrt(noise_avg_watts), len(data**2))
  # Noise up the original signal
  data = data + added_noise
  return(data,added_noise)


num_train = 14
#### Step 1 #####
t, S, D = find_audio(file_bin,num_train)
# Use this to test
#for signal in D:
  #print(signal)
  #print(np.shape(D[signal]))


#### Step 2 ####
WF = Frames(D)
# Use this to test
#for signal in range(len(WF)):
  #print('signal is: ',signal)
  #print(np.shape(WF[signal]))


#### Step 3 ####
MAG,POW,POWdB = MAGPOW(WF)
choice = 0
plot_POWdB(POWdB[choice],t[choice],fs=12500)


#### Step 4 ####
band_pass, myBanks = melBanks(num_filt=num_filt,f_samp=f_samp,num_FFT=num_FFT,POW=POW)
plot_BandPassBank(band_pass,freq)
choice = 0
plot_melbanks(myBanks[choice],t[choice],f_samp=12500)


#### Step 5 ####
mfccs = find_mfccs(myBanks,num_ceps=12)
choice = 0
plot_mfccs(mfccs[choice],t[choice])

#### Step 6 ####

clusters = {}
centroids = {}
for speaker in range(num_train):
  clusters[speaker], centroids[speaker] = cluster_buster(mfccs[speaker],M)

#### Use this for plotting clusters ####
fig, ax1 = plt.subplots(nrows=1,ncols=1,figsize=[20,10])
color = ['r','orange','y','g','lawngreen','b','c','m','black','brown','purple','darkgreen','goldenrod','violet','tomato','crimson','mediumspringgreen']
import random
r = random.sample(range(len(mfccs)-2), 2)
r2 = random.randint(0,num_train-1)
print('r is: ',r)
print('r2 is: ',r2-1)
for centroid in clusters[r2]:
  for point in clusters[r2][centroid]:
    ax1.scatter(mfccs[r2][point,r[0]],mfccs[r2][point,r[1]],color=color[centroid],s=100)
  ax1.scatter(centroids[r2][centroid][r[0]],centroids[r2][centroid][r[1]],color=color[centroid],s=400,marker='^',label='Centroid'+str(centroid+1))
ax1.set_ylabel('Dimension '+str(r[0]+1), fontsize=15, weight='bold',color='black')
ax1.set_xlabel('Dimension '+str(r[1]+1), fontsize=15, weight='bold',color='black')
ax1.set_title('Plot of Clusters and Centroids for Speaker '+str(r2+1), fontsize=20, weight='bold',color='black')
ax1.legend(bbox_to_anchor=(1.15, 1),fontsize=20)
ax1.grid()
plt.tight_layout()
plt.show()

## look up globglob and os file imports to make more usable 


test_files = '/content/drive/MyDrive/Colab Notebooks/EEC 201/Final Project/Test/s'
num_test = 16
#### Step 1 #####
tT, ST, DT = find_audio(test_files,num_test)
#### Step 2 ####
WFT = Frames(DT)
#### Step 3 ####
MAGT,POWT,POWdBT = MAGPOW(WFT)
#### Step 4 ####
band_passT, myBanksT = melBanks(num_filt=num_filt,f_samp=f_samp,num_FFT=num_FFT,POW=POWT)
#### Step 5 ####
mfccsT = find_mfccs(myBanksT,num_ceps=12)
### Step 6 ####


Distortion = np.zeros([num_train,num_test])
for speaker in range(num_test):
  for data_point in range(np.shape(mfccsT[speaker])[0]):
    for trainer in range(num_train):
      min_dist = 1E4
      for centroid in range(M):
        temp_dist = np.linalg.norm(mfccsT[speaker][data_point] - centroids[trainer][centroid])
        if temp_dist < min_dist:
          min_dist = temp_dist # distance current point is from centroid
      Distortion[trainer][speaker] += min_dist

DF = pd.DataFrame(Distortion)


print('\n\n\n\n')
havent_used = np.zeros(num_test)
for col in range(np.shape(Distortion)[1]):
  Distortion[:,col] = Distortion[:,col]/len(mfccsT[col])
  Distortion[:,col] = Distortion[:,col]/np.min(Distortion[:,col])
  havent_used[col] = np.min(Distortion[np.where(Distortion[:,col]>1),col])-1
  Distortion[:,col] = Distortion[:,col]/np.max(Distortion[:,col])
  winner = (np.where(Distortion[:,col]==np.min(Distortion[:,col]))[0]) 
  print('Trainer',str(winner[0]+1),'is the most similar to speaker '+str(col+1)+' with '+str(np.floor(havent_used[col]*100))+'% margin')
print('\n\n\n\n')
#print(havent_used)


fig1, axs1 = plt.subplots(nrows=1,ncols=1,figsize=[10,5])
c = axs1.pcolor(Distortion)
axs1.set_title('Speaker Comparison', weight='bold',fontsize=20,color='black')
plt.xticks(fontsize=15)
plt.yticks(fontsize=15)
axs1.set_ylabel('Trainers',weight='bold',size=15)
axs1.set_xlabel('Test Speakers',weight='bold',size=15)
fig1.colorbar(c , ax = axs1)
plt.tight_layout()

noisy_signal = {}
noise = {}
noise_test = [40,25,15,5]
for test in range(len(noise_test)):
  noisy_signal[test], noise[test] = SNR(noise_test[test],DT[0])


L_test = len (noise_test)
fig, axs = plt.subplots(nrows=L_test, ncols=1, figsize=[20,20])
for test in range(L_test):
  axs[test].plot(noisy_signal[test])
  axs[test]
plt.tight_layout()



#### Step 2 ####
WFT = Frames(noisy_signal)
#### Step 3 ####
MAGT,POWT,POWdBT = MAGPOW(WFT)
#### Step 4 ####
band_passT, myBanksT = melBanks(num_filt=num_filt,f_samp=f_samp,num_FFT=num_FFT,POW=POWT)
#### Step 5 ####
mfccsT = find_mfccs(myBanksT,num_ceps=12)
### Step 6 ####


num_test = len(noise_test)
Distortion = np.zeros([num_train,num_test])
for speaker in range(num_test):
  for data_point in range(np.shape(mfccsT[speaker])[0]):
    for trainer in range(num_train):
      min_dist = 1E4
      for centroid in range(M):
        temp_dist = np.linalg.norm(mfccsT[speaker][data_point] - centroids[trainer][centroid])
        if temp_dist < min_dist:
          min_dist = temp_dist # distance current point is from centroid
      Distortion[trainer][speaker] += min_dist

DF = pd.DataFrame(Distortion)


print('\n\n\n\n')
havent_used = np.zeros(num_test)
for col in range(np.shape(Distortion)[1]):
  Distortion[:,col] = Distortion[:,col]/len(mfccsT[col])
  Distortion[:,col] = Distortion[:,col]/np.min(Distortion[:,col])
  havent_used[col] = np.min(Distortion[np.where(Distortion[:,col]>1),col])-1
  Distortion[:,col] = Distortion[:,col]/np.max(Distortion[:,col])
  winner = (np.where(Distortion[:,col]==np.min(Distortion[:,col]))[0]) 
  print('Trainer',str(winner[0]+1),'is the most similar to noise speaker 1 noise test '+str(col+1)+' with '+str(np.floor(havent_used[col]*100))+'% margin')
print('\n\n\n\n')
#print(havent_used)


fig1, axs1 = plt.subplots(nrows=1,ncols=1,figsize=[10,5])
c = axs1.pcolor(Distortion)
axs1.set_title('Speaker Comparison\nDark Areas are most likely Trainer for Speaker', weight='bold',fontsize=20,color='black')
plt.xticks(fontsize=15)
plt.yticks(fontsize=15)
axs1.set_ylabel('Trainers',weight='bold',size=15)
axs1.set_xlabel('Test Speakers',weight='bold',size=15)
fig1.colorbar(c , ax = axs1)
plt.tight_layout()